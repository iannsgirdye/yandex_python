# Есть варианты?

"""
ПРИМЕР
6 человек, 2 стула  =>  15 вариантов, 1/3 вероятность занять место
1/3 = ?/15  =>  ? = 15 // 3 (т.е. math.comb(6, 2) * (6 // 2))

ПРИМЕЧАНИЕ
Если выражение M // N вычислять отдельно, то значение будет постоянно 0 или 1, так как M <= N.
Поэтому в таком случае нужно вычислять значение выражения M / N, а затем подставлять в good_variants.
Но тогда 7-й тест не будет пройден:
    Line 1 differs: out:
    >9967310565986162 51705423561053205<
    corr:
    >9967310565986160 51705423561053205<
Вероятнее всего небольшая погрешность возникает из-за особенностей хранения вещественных чисел в памяти:
например, при умножении 1.6, которое на самом деле 1.59999999... (если это так), на огромное число возникает
незначительное расхождение (9967310565986162 - 9967310565986160 = 2, что незначительно при величине значений)
"""

import math

N, M = map(int, input().split())  # Количества людей и мест
places = math.comb(N, M)          # Всего мест
good_variants = places * M // N   # Хорошие варианты
print(int(good_variants), places)
